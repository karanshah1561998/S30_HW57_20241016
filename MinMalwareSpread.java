// Problem 924. Minimize Malware Spread
// Time Complexity : O(n*n)
// Space Complexity : O(n)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this :

// Your code here along with comments explaining your approach
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] colors = new int[n];
        Arrays.fill(colors, -1);
        int cl = 0;
        for (int i = 0; i < n; i++) {
            if (colors[i] == -1) {
                dfs(colors, graph, i, cl);
                cl++;
            }
        }
        // count the number of nodes in each color group
        int[] groups = new int[cl];
        for (int i = 0; i < n; i++) {
            int c = colors[i];
            groups[c] += 1;
        }
        // count the number of initial infected nodes in each group
        int[] initGroups = new int[cl];
        for (int node : initial) {
            int c = colors[node];
            initGroups[c] += 1;
        }
        // find the node that, when removed, minimizes the spread of malware
        int result = Integer.MAX_VALUE;
        for (int node : initial) {
            int c = colors[node];
            // if this node is the only one infected in its group
            if (initGroups[c] == 1) {
                // choose the largest group, break ties by node index
                if (result == Integer.MAX_VALUE || groups[c] > groups[colors[result]] ||
                    (groups[c] == groups[colors[result]] && node < result)) {
                    result = node;
                }
            }
        }
        // if no node can reduce the malware spread, return the smallest index
        if (result == Integer.MAX_VALUE) {
            result = Integer.MAX_VALUE;
            for (int node : initial) {
                result = Math.min(result, node);
            }
        }
        return result;
    }
    private void dfs(int[] colors, int[][] graph, int node, int color) {
        colors[node] = color;
        for (int i = 0; i < graph.length; i++) {
            if (graph[node][i] == 1 && colors[i] == -1) {
                dfs(colors, graph, i, color);
            }
        }
    }
}
